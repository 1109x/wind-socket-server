<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Ink Words Flow</title>

  <!-- p5.js -->
  <script src="https://cdn.jsdelivr.net/npm/p5@1.9.4/lib/p5.min.js"></script>
  <!-- socket.io client from YOUR server (same origin) -->
  <script src="/socket.io/socket.io.js"></script>

  <style>
    html, body { margin:0; padding:0; overflow:hidden; background: rgb(248,246,242); }
    #hud{
      position:fixed; left:12px; top:12px;
      padding:10px 12px;
      border-radius:12px;
      background: rgba(0,0,0,0.30);
      color: rgba(255,255,255,0.95);
      font: 13px/1.25 system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
      user-select:none;
      backdrop-filter: blur(6px);
      pointer-events:none;
      min-width: 240px;
    }
    #dot{display:inline-block;width:10px;height:10px;border-radius:50%;background:#f55;margin-right:8px;vertical-align:middle}
  </style>
</head>

<body>
  <div id="hud"><span id="dot"></span><span id="msg">Loading…</span></div>

  <script>
    // ================= Socket (SAME ORIGIN) =================
    const dot = document.getElementById("dot");
    const msg = document.getElementById("msg");

    let socket;
    let wind = { x: 0, y: 0, strength: 0 };

    // ✅ 关键改动：同源连接，不写 SERVER_URL
    socket = io();

    socket.on("connect", () => {
      dot.style.background = "#5f5";
      msg.textContent = "Connected. Tilt phone to move ink.";
    });

    socket.on("wind", (s) => {
      wind = s || wind;
    });

    // ================= Your sketch (same effect) =================

    // ✅ 用完整单词（不是字母）
    const WORDS = ["Spring","Summer","Autumn","Winter"];
    let wordIndex = 0;
    function nextWord() {
      const w = WORDS[wordIndex % WORDS.length];
      wordIndex++;
      return w;
    }

    let pg;
    let glyphs = [];
    let wet = { x: 0, y: 0 };

    const PAPER = [248, 246, 242];
    const FADE_ALPHA = 10;
    const NUM_GLYPHS = 70;   // 更少一些
    const WIND_SCALE = 0.55;
    const DRAG = 0.90;
    const FLOW_SCALE = 0.0035;
    const FLOW_STRENGTH = 0.10;
    const WET_RADIUS_BASE = 240;
    const WET_BLEED = 0.6;
    const REPEL_SOFT = 0.10;

    function setup() {
      createCanvas(window.innerWidth, window.innerHeight);

      pg = createGraphics(window.innerWidth, window.innerHeight);
      pg.pixelDensity(1);
      pg.background(...PAPER);
      pg.textAlign(CENTER, CENTER);

      wet.x = width * 0.5;
      wet.y = height * 0.5;

      initGlyphs();
    }

    function initGlyphs() {
      glyphs = [];

      const grid = Math.sqrt(NUM_GLYPHS);
      const stepX = width / grid;
      const stepY = height / grid;

      for (let gy = 0; gy < grid; gy++) {
        for (let gx = 0; gx < grid; gx++) {
          if (glyphs.length >= NUM_GLYPHS) break;

          const x = (gx + 0.5) * stepX + random(-stepX * 0.25, stepX * 0.25);
          const y = (gy + 0.5) * stepY + random(-stepY * 0.25, stepY * 0.25);

          // 大小不一：大词少，小词多
          const r = random();
          const size =
            r < 0.18 ? random(44, 62) :
            r < 0.50 ? random(26, 40) :
                       random(16, 24);

          glyphs.push({
            x, y,
            vx: 0, vy: 0,
            word: nextWord(),
            size,
            seed: random(1000),
          });
        }
      }
    }

    function draw() {
      // 纸面轻擦，保持干净
      pg.noStroke();
      pg.fill(PAPER[0], PAPER[1], PAPER[2], FADE_ALPHA);
      pg.rect(0, 0, pg.width, pg.height);

      const wx = (wind.x || 0) * (wind.strength || 0) * WIND_SCALE;
      const wy = (wind.y || 0) * (wind.strength || 0) * WIND_SCALE;

      wet.x = wrap(lerp(wet.x, wet.x + wx * 520, 0.05), width);
      wet.y = wrap(lerp(wet.y, wet.y + wy * 520, 0.05), height);

      const t = frameCount * 0.010;
      const wetRadius = WET_RADIUS_BASE + (wind.strength || 0) * 160;

      softSeparate(glyphs, 34, REPEL_SOFT);

      for (const g of glyphs) {
        const n = noise(g.x * FLOW_SCALE, g.y * FLOW_SCALE, t);
        const ang = n * TWO_PI * 2.0;
        const fx = cos(ang) * FLOW_STRENGTH;
        const fy = sin(ang) * FLOW_STRENGTH;

        const d = distWrap(g.x, g.y, wet.x, wet.y, width, height);
        const wetAmt = smoothstep(wetRadius, 0, d);

        const wetPull = 0.18 + 0.90 * wetAmt;
        const jitter = WET_BLEED * wetAmt * (0.6 + 0.4 * (wind.strength || 0));

        g.vx = (g.vx + (fx + wx) * wetPull) * DRAG;
        g.vy = (g.vy + (fy + wy) * wetPull) * DRAG;

        g.x = wrap(g.x + g.vx, width);
        g.y = wrap(g.y + g.vy, height);

        const baseA = 120;
        const wetA = 70 * wetAmt;
        const alpha = baseA - wetA;

        pg.textSize(g.size);

        // 主字（整词）
        pg.noStroke();
        pg.fill(20, 20, 24, alpha);
        pg.text(g.word, g.x, g.y);

        // 湿区晕染层（轻）
        if (wetAmt > 0.03) {
          pg.fill(20, 20, 24, alpha * 0.18);
          pg.text(g.word, g.x + random(-jitter, jitter), g.y + random(-jitter, jitter));
          pg.text(g.word, g.x + random(-jitter, jitter), g.y + random(-jitter, jitter));
        }

        // 偶尔换词（很克制）
        if (frameCount % 360 === 0 && random() < 0.10) {
          g.word = nextWord();
        }
      }

      if (frameCount % 28 === 0) pg.filter(BLUR, 0.45);

      image(pg, 0, 0);

      // HUD
      msg.textContent =
        `wind: (${(wind.x||0).toFixed(2)}, ${(wind.y||0).toFixed(2)})  s:${(wind.strength||0).toFixed(2)}`;
    }

    function windowResized() {
      resizeCanvas(window.innerWidth, window.innerHeight);

      const old = pg;
      pg = createGraphics(window.innerWidth, window.innerHeight);
      pg.pixelDensity(1);
      pg.background(...PAPER);
      pg.textAlign(CENTER, CENTER);
      pg.image(old, 0, 0, pg.width, pg.height);

      initGlyphs();
    }

    // ===== helpers =====
    function wrap(v, max) {
      if (v < 0) return v + max;
      if (v > max) return v - max;
      return v;
    }

    function distWrap(x1, y1, x2, y2, w, h) {
      let dx = Math.abs(x1 - x2);
      let dy = Math.abs(y1 - y2);
      dx = Math.min(dx, w - dx);
      dy = Math.min(dy, h - dy);
      return Math.sqrt(dx * dx + dy * dy);
    }

    function smoothstep(edge0, edge1, x) {
      const t = clamp((x - edge0) / (edge1 - edge0), 0, 1);
      return t * t * (3 - 2 * t);
    }

    function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }

    // ✅ 这里是你之前贴到一半缺失的结尾，我帮你补齐了
    function softSeparate(arr, minD, strength) {
      for (let i = 0; i < arr.length; i++) {
        const a = arr[i];
        for (let j = i + 1; j < Math.min(arr.length, i + 10); j++) {
          const b = arr[j];

          let dx = a.x - b.x;
          let dy = a.y - b.y;

          if (Math.abs(dx) > width / 2) dx = -Math.sign(dx) * (width - Math.abs(dx));
          if (Math.abs(dy) > height / 2) dy = -Math.sign(dy) * (height - Math.abs(dy));

          const d2 = dx * dx + dy * dy;
          if (d2 > 0.0001 && d2 < minD * minD) {
            const d = Math.sqrt(d2);
            const push = (minD - d) / minD * strength;
            const nx = dx / d, ny = dy / d;
            a.vx += nx * push;
            a.vy += ny * push;
            b.vx -= nx * push;
            b.vy -= ny * push;
          }
        }
      }
    }
  </script>
</body>
</html>
